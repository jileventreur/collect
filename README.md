# ranges::collect 

An implementation of rust [collect][1] for c++23

## Principle

The `ranges::collect` function is a useful tool when working with `std::ranges` containing types such as `std::expected` or `std::optional`.
Calling `ranges::collect` will give you all the values of the potential type if they are all valid, or the potential error if one of them fails.
In other words:

* It converts a `range<expected<value, error>>` into an `expected<range<value>, error>`
* It converts a `range<optional<value>>` into an `optional<range<value>>`

## Basic Example 

```cpp
using VecOfExp = std::vector<std::expected<int, std::string>>;
using ExpOfVec = std::expected<std::vector<int>, std::string>;
VecOfExp has_error = { 1, std::unexpected("NOT INT"), 3};
VecOfExp no_error = {1, 2, 3};

ExpOfVec exp_error = has_error | ranges::collect();
ExpOfVec exp_value = no_error | ranges::collect();
/// same as: 
// auto result = ranges::collect(no_error);

auto print = [](const auto& expected) {
    if (expected.has_value())
        fmt::println("Valid result : {}", expected.value());
    else
        fmt::println("Error : {}", expected.error());
};

print(exp_error);
print(exp_value);
```
**Output:**
```
Error : NOT INT
Valid result : [1, 2, 3]
```
If you want to try it, you can start playing with it [here][2]

## Requirements
`ranges::collect` uses `std::ranges::range_adaptor_closure` from the c++23 standard to operate.

To know if you can use it, you'll need to check that your compiler implements it.

The features and concepts of the std::ranges c++20 library are also required.
On the other hand, std::expected or std::optional are not necessary and can be replaced by equivalents (which respect the same behavior). 

This function could easily be implemented to work with the c++20 standard in the future.

## Installation
`collect` is not available in any package manager at the moment. 
The function is contained in a single header file that can be found at [include/collect.h][2]. So you can easily copy it and integrate it into your project.
If you want to run the tests, you'll need CMake version .14 or higher.

## Possibilities

`ranges::collect` is greatly inspired by `std::ranges::to` so a lot of things working with `std::ranges::to` should work for `ranges::collect` too.

For Example:

* You can specify the container return type:
```cpp
std::vector<std::optional<int>> vec = { 1, std::nullopt, 3};
std::optional<std::list<int>> exp_error = vec | ranges::collect<std::list<int>>();
```

*  Value of the returned container can be deduced :
```cpp
std::vector<std::optional<int>> vec = { 1, std::nullopt, 3};
std::optional<std::list<int>> exp_error = vec | ranges::collect<std::list>();
```

*  Works with associative containers :
```cpp
    std::vector vec{
        std::optional(std::pair<int, int>(0, 1)),
         std::optional(std::pair<int, int>(2, 3)),
         std::optional(std::pair<int, int>(4, 5)),
    };
    std::optional<std::map<int, int>> res = vec | ranges::collect<std::map<int, int>>();
```

* Works with nested containers of expected or optional like type :
```cpp
std::vector<std::vector<std::expected<int, std::string>>> vec2d = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
};
std::expected<std::list<std::list<int>> res = vec2d | ranges::collect<std::list<std::list<int>>>();
```

* You can provide the returned container args if needed :
```cpp
std::vector<std::optional<int>> vec = { 1, std::nullopt, 3};
std::pmr::monotonic_buffer_resource buffer {/* ...*/};
std::optional<std::pmr::vector<int>> res = vec | ranges::collect<std::pmr::vector<int>>(&buffer);
```
* Works with any input range and custom container for the output
* is constexpr compatible (as all the things should :D)

**About `std::expected` and `std::optional`** 

use of standard expected or optional is not mandatory and you can use any type following their behavior as input. The same type wille be used as output to encapsulate the returned container.
So you can use any custom implementation like [tl::expected][2] or [tl::optional][3]

If you wish to use your own implementation, your type must follow the expected_like or optional_like concepts provided in the collect.h header file.

## Limitations

* Unlike the [collect][1] function in rust, `ranges::collect` only works on ranges containing a `optional` or `expected`. for other ranges the collect function in rust acts like `std::ranges:to` so you should use it instead.

This is a work in progress and those limitations should be removed in a near future in master or in a parallel branch.

## Performance notes
Like `std::filter`, `ranges::collect` need to access to the range value twice. One for checking that .has_value() is true and a second time to actually use it. So, if the value is generated by a `std::transform` or similar, the calculation will occur twice.
To avoid it, use range-v3 [cache1][5] or [views::cache_last][6] (once added in the standard and implemented by your compiler).

To enhance performance `ranges::collect` will only allocate if all the value are good and the range is at least a `std::forward_range`.
For `std::input_range`, result values are allocated on the fly and destroyed if an error is encountered in the range values.


---

*Special thanks to Sy Brand and his `std::ranges::to` implementation [video][7], which taught me a lot about how to implement this project.*

  [1]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect
  [2]: https://godbolt.org/z/4bGo5jfsv
  [3]: https://github.com/jileventreur/collect/blob/master/include/collect.h
  [4]: https://github.com/TartanLlama/expected
  [5]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect
  [6]: https://ericniebler.github.io/range-v3/structranges_1_1views_1_1cache1__fn.html
  [7]: https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3138r0.html
  [8]: https://www.youtube.com/watch?v=lU403RAZV0I
